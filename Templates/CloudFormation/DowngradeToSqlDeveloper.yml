---
AWSTemplateFormatVersion: '2010-09-09'
Description: AWS CloudFormation templates to create resources to automate the installation and migration of the databases to Microsoft SQL developer edition.
  Resources includes IAM role, Amazon Amazon S3 and AWS Systems Manager Automation.
Parameters:
  MSsqlSecretKey:
    Type: String
    Description: "(Required) The name of an Secret Key that have access this permission to the SQL server."
Resources:
  LocalAdministratorSecret:
    Type: 'AWS::SecretsManager::Secret'
    Properties:
      Description: !Sub 'Password for local administrator password on new instance. Generated by the CFN for stack: ${AWS::StackName}'
      Name:
        !Sub
          - 'LocalAdministratorSecret-${RandomGUID}'
          - { RandomGUID: !Select [0, !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId ]]]] }
      GenerateSecretString:
        ExcludeCharacters: ' %+~`#$&*()|[]{}:;<>?!''/@"\'
        GenerateStringKey: password
        PasswordLength: 30
        SecretStringTemplate: '{"username":"Administrator"}'
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SSMInstanceProfileRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - secretsmanager:GetSecretValue
              Resource:
                - !Ref LocalAdministratorSecret
                - !Sub arn:${AWS::Partition}:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${MSsqlSecretKey}-*
          PolicyName: GetSecretManagerValue
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - ssm:GetParameter
              Resource:
                Fn::Sub: arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*
          PolicyName: GetParameter
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags:
        - Key: CloudFormationStackId
          Value: !Ref AWS::StackId
        - Key: CloudFormationStackName
          Value: !Ref AWS::StackName
  SSMInstanceProfile:
    Type: 'AWS::IAM::InstanceProfile'
    Properties:
      Roles:
        - !Ref SSMInstanceProfileRole
  AWSSystemsManagerAutomationRole:
      Type: 'AWS::IAM::Role'
      Properties:
        Description: !Sub "Role create as part of cloudformation stack id ${AWS::StackId}."
        AssumeRolePolicyDocument:
          Version: 2012-10-17
          Statement:
            - Effect: Allow
              Principal:
                Service: ssm.amazonaws.com
              Action:
                - 'sts:AssumeRole'
        ManagedPolicyArns:
          - 'arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole'
        Path: /
        Policies:
          - PolicyName: AWS-SQL-Developer-Edition-Policy
            PolicyDocument:
              Version: 2012-10-17
              Statement:
                - Effect: Allow
                  Action:
                    - 'ec2:DescribeInstances'
                    - "license-manager:CreateLicenseConversionTaskForResource"
                  Resource: '*'
                - Effect: Allow
                  Action:
                    - 'iam:PassRole'
                  Resource:
                    - Fn::GetAtt:
                      - SSMInstanceProfile
                      - Arn
                    - Fn::GetAtt:
                      - SSMInstanceProfileRole
                      - Arn
                - Effect: Allow
                  Action:
                    - 'ec2:RebootInstances'
                    - 'ec2:StopInstances'
                  Resource: '*'
                  Condition:
                    StringLike:
                      aws:ResourceTag/Name:
                      - SQL_Dev_Edition_????????-????-????-????-????????????
        Tags:
          - Key: CloudFormation StackId
            Value: !Ref AWS::StackId
  CommandDocumentSqlDevMigration:
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: '2.2'
        description: 'Run a script on Windows instances to compare SQL versions.'
        mainSteps:
        - action: aws:runPowerShellScript
          name: runPowerShellScript
          inputs:
            timeoutSeconds: '60'
            runCommand:
              - "try { "
              - "    New-Item -Path 'C:\\AWSsqlDeveloperEditionBlog\\SQLDevAddRoutesScript' -ItemType Directory -Force"
              - "    write-host \"Directory C:\\AWSsqlDeveloperEditionBlog\\SQLDevAddRoutesScript created\""
              - ""
              - "@'"
              - "        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved."
              - "        #"
              - "        # Licensed under the Amazon Software License (the \"License\")."
              - "        # You may not use this file except in compliance with the License."
              - "        # A copy of the License is located at"
              - "        #"
              - "        # http://aws.amazon.com/asl/"
              - "        #"
              - "        # or in the \"license\" file accompanying this file. This file is distributed"
              - "        # on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either"
              - "        # express or implied. See the License for the specific language governing"
              - "        # permissions and limitations under the License."
              - ""
              - "        <#-----------------------------------------------------------------------------------------------------------"
              - "            FilterIPAddresses filters for valid ip addresses in the given array that match the given address family."
              - "        -------------------------------------------------------------------------------------------------------------#>"
              - "        function FilterIPAddresses"
              - "        {"
              - "          param("
              - "            [Parameter(Mandatory = $true,ValueFromPipeline = $true)]"
              - "            [string[]]$Addresses,"
              - "            [Parameter(Mandatory = $true)]"
              - "            [string]$AddressFamily"
              - "          )"
              - "          $ErrorActionPreference = \"Stop\""
              - ""
              - "          $Addresses.Where({"
              - "              try"
              - "              {"
              - "                return ([ipaddress]$_).AddressFamily -eq $AddressFamily"
              - "              }"
              - "              catch"
              - "              {"
              - "                # Not a valid ip address, filter it out anyways"
              - "                return $false"
              - "              }"
              - "            })"
              - "        }"
              - ""
              - "        <#-----------------------------------------------------------------------------------------------------------"
              - "            Add-Routes routes connections to metadata service, KMS VPC 1 & 2, and AMZ time sync service."
              - "        -------------------------------------------------------------------------------------------------------------#>"
              - "        function Add-Routes"
              - "        {"
              - "          # Comment to avoid IMDS V2 scanner, X-aws-ec2-metadata-token-ttl-seconds"
              - "          # 169.254.169.254 is for metadata service"
              - "          # 169.254.169.250 is for KmsInstanceVpc1"
              - "          # 169.254.169.251 is for KmsInstanceVpc2"
              - "          # 169.254.169.249 is for G3GridLicense"
              - "          # 169.254.169.123 is for AmzTimeSyncServiceVipIp"
              - "          # 169.254.169.253 is for DNS server"
              - "          $iPv4Addrs = @(\"169.254.169.254/32\",\"169.254.169.250/32\",\"169.254.169.251/32\",\"169.254.169.249/32\",\"169.254.169.123/32\",\"169.254.169.253/32\")"
              - ""
              - "          $sleepTime = 1"
              - "          $count = 0"
              - ""
              - "          # Retry logic for querying primary network interface and adding routes."
              - "          while ($true)"
              - "          {"
              - "            try"
              - "            {"
              - "              write-host \"Checking primary network interface\""
              - ""
              - "              function New-RoutesArray"
              - "              {"
              - "                param("
              - "                  [Parameter(Mandatory = $true)]"
              - "                  [string]$NextHop,"
              - "                  [Parameter(Mandatory = $true)]"
              - "                  [string[]]$Destinations"
              - "                )"
              - ""
              - "                $routes = @()"
              - "                foreach ($destination in $Destinations)"
              - "                {"
              - "                  $routes += [pscustomobject]@{ Destination = $destination; NextHop = $NextHop }"
              - "                }"
              - ""
              - "                return $routes"
              - "              }"
              - ""
              - "              # If the current platform is not Nano, use this implementation for a better performance."
              - "              if (-not (Test-NanoServer))"
              - "              {"
              - "                $networkAdapter = Get-CimInstance -ClassName Win32_NetworkAdapter -Filter \"AdapterTypeId='0' AND NetEnabled='True' AND NOT Name LIKE '%Hyper-V Virtual%' AND NOT Name LIKE '%Loopback Adapter%' AND NOT Name LIKE '%TAP-Windows Adapter%'\" | Sort-Object -Property \"InterfaceIndex\" | Select-Object InterfaceIndex"
              - "                if (-not $networkAdapter -or $networkAdapter.Length -eq 0)"
              - "                {"
              - "                  throw New-Object System.Exception (\"Failed to find the primary network interface\")"
              - "                }"
              - "                $interfaceIndex = $networkAdapter[0].InterfaceIndex"
              - "                $networkAdapterConfig = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -Filter \"InterfaceIndex='$interfaceIndex'\" | Select-Object IPConnectionMetric,DefaultIPGateway"
              - ""
              - "                function New-RoutesArrayForAddressFamily"
              - "                {"
              - "                  param("
              - "                    [Parameter(Mandatory = $true)]"
              - "                    [string]$AddressFamily,"
              - "                    [Parameter(Mandatory = $true)]"
              - "                    [string[]]$Destinations"
              - "                  )"
              - ""
              - "                  [string[]]$defaultGateways = @(FilterIPAddresses -Addresses $networkAdapterConfig.DefaultIPGateway -AddressFamily $AddressFamily)"
              - "                  if ($defaultGateways.Length -ne 0)"
              - "                  {"
              - "                    $defaultGateway = $defaultGateways[$defaultGateways.Length - 1]"
              - "                    return New-RoutesArray -NextHop $defaultGateway -Destinations $Destinations"
              - "                  }"
              - ""
              - "                  return @()"
              - "                }"
              - ""
              - "                $routes = New-RoutesArrayForAddressFamily -AddressFamily \"InterNetwork\" -Destinations $iPv4Addrs"
              - ""
              - "                # fd00:ec2::254 is for metadata service"
              - "                # fd00:ec2::250 is for KmsInstanceVpc1"
              - "                # fd00:ec2::123 is for AmzTimeSyncServiceVipIp"
              - "                # fd00:ec2::253 is for DNS server"
              - "                $iPv6Addrs = @(\"fd00:ec2::254/128\",\"fd00:ec2::250/128\",\"fd00:ec2::123/128\",\"fd00:ec2::253/128\")"
              - "                $routes += New-RoutesArrayForAddressFamily -AddressFamily \"InterNetworkV6\" -Destinations $iPv6Addrs"
              - ""
              - "                if ($null -eq $routes -or @($routes).Count -eq 0)"
              - "                {"
              - "                  # The intent is to fail this attempt at adding routes and trigger a retry."
              - "                  # The NIC takes a while to fully initialize sometimes. We need to wait for it."
              - "                  # NIC uninitialized -> no default gateway associated with NIC -> adding routes"
              - "                  # fails due to no default gateway."
              - "                  throw New-Object System.Exception (\"No routes to add\")"
              - "                }"
              - ""
              - "                $interfaceMetric = $networkAdapterConfig.IPConnectionMetric"
              - "              }"
              - "              else"
              - "              {"
              - "                $ipConfigs = Get-NetIPConfiguration | Sort-Object -Property \"InterfaceIndex\" | Select-Object InterfaceIndex,IPv4DefaultGateway"
              - "                if (-not $ipConfigs -or $ipConfigs.Length -eq 0)"
              - "                {"
              - "                  throw New-Object System.Exception (\"Failed to find the primary network interface\")"
              - "                }"
              - "                $primaryIpConfig = $ipConfigs[0]"
              - "                $interfaceIndex = $primaryIpConfig.InterfaceIndex"
              - "                $defaultIPv4Gateway = $primaryIpConfig.IPv4DefaultGateway.NextHop"
              - ""
              - "                $routes = New-RoutesArray -NextHop $defaultIPv4Gateway -Destinations $iPv4Addrs"
              - ""
              - "                $interfaceMetric = 1"
              - "              }"
              - ""
              - "              write-host \"Primary network interface found. Adding routes now...\""
              - ""
              - "              foreach ($route in $routes)"
              - "              {"
              - "                try"
              - "                {"
              - "                  Remove-NetRoute -DestinationPrefix $route.Destination -PolicyStore ActiveStore -Confirm:$false -ErrorAction SilentlyContinue"
              - "                  Remove-NetRoute -DestinationPrefix $route.Destination -PolicyStore PersistentStore -Confirm:$false -ErrorAction SilentlyContinue"
              - "                  New-NetRoute -DestinationPrefix $route.Destination -InterfaceIndex $interfaceIndex `"
              - "                    -NextHop $route.NextHop -RouteMetric $interfaceMetric -ErrorAction Stop"
              - "                  write-host (\"Successfully added the Route: {0}, gateway: {1}, NIC index: {2}, Metric: {3}\" `"
              - "                      -f $route.Destination,$route.DefaultGateway,$interfaceIndex,$interfaceMetric)"
              - "                }"
              - "                catch"
              - "                {"
              - "                  write-host \"Failed to add routes: {0}\" $route.Destination"
              - "                }"
              - "              }"
              - ""
              - "              write-host (\"Resyncing w32tm\")"
              - "              w32tm /resync /rediscover /nowait"
              - ""
              - "              # Break if routes are added successfully."
              - "              break"
              - "            }"
              - "            catch"
              - "            {"
              - "              write-host \"Failed to add routes.. attempting it again {0}\" $_.Exception.Message"
              - "            }"
              - ""
              - "            # It logs the status every 2 minutes."
              - "            if (($count * $sleepTime) % 120 -eq 0)"
              - "            {"
              - "              write-host \"Message: Failed to add routes.. attempting it again\" -LogToConsole"
              - "            }"
              - ""
              - "            Start-Sleep -Seconds $sleepTime"
              - "            $count++"
              - "          }"
              - "        }"
              - ""
              - "        <#-----------------------------------------------------------------------------------------------------------"
              - "            Test-NanoServer retreives the OS Sku number and check if it is 143 or 144 which represents nano server."
              - "        -------------------------------------------------------------------------------------------------------------#>"
              - "        function Test-NanoServer"
              - "        {"
              - "          try"
              - "          {"
              - "            if (-not $script:skuNumber)"
              - "            {"
              - "              Set-Variable skuNumber -Option Constant -Scope Script -Value ((Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object OperatingSystemSKU).OperatingSystemSKU)"
              - "            }"
              - "            return $script:skuNumber -eq 143 -or $script:skuNumber -eq 144"
              - "          }"
              - "          catch"
              - "          {"
              - "            return $false"
              - "          }"
              - "        }"
              - ""
              - "        Add-Routes"
              - "'@ | Set-Content -Path C:\\AWSsqlDeveloperEditionBlog\\SQLDevAddRoutesScript\\addroutes.ps1 -Force"
              - ""
              - "    write-host \"PowerShell Script Directory C:\\AWSsqlDeveloperEditionBlog\\SQLDevAddRoutesScript\\addroutes.ps1 created\""
              - ""
              - "    # Create a new task action"
              - "    $taskAction = New-ScheduledTaskAction `"
              - "        -Execute 'C:\\Windows\\System32\\cmd.exe' `"
              - "        -Argument '/C C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -NoProfile -NonInteractive -NoLogo -ExecutionPolicy Unrestricted -File \"C:\\AWSsqlDeveloperEditionBlog\\SQLDevAddRoutesScript\\addroutes.ps1\"'"
              - ""
              - "    # Create a new trigger"
              - "    $taskTrigger = New-ScheduledTaskTrigger -AtStartup"
              - ""
              - ""
              - "    # The name of your scheduled task."
              - "    $taskName = \"SQLDevAddRoutes\""
              - ""
              - "    # Describe the scheduled task."
              - "    $description = \"Fixed Windows Route table to access the metadata when create a new instance in a new subnet.\""
              - ""
              - "    # Register the scheduled task"
              - "    Register-ScheduledTask `"
              - "        -Force `"
              - "        -TaskName $taskName `"
              - "        -Action $taskAction `"
              - "        -Trigger $taskTrigger `"
              - "        -Description $description `"
              - "        -User \"System\" `"
              - "        -RunLevel \"Highest\""
              - ""
              - "    write-host \"Scheduled Task name SQLDevAddRoutes created\"                "
              - "}"
              - "catch { "
              - "exit 1"
              - "}"
      DocumentFormat: YAML
      DocumentType: Command
  AutomationDocumentSqlDevMigration:
    Type: AWS::SSM::Document
    Properties:
      DocumentFormat: YAML
      DocumentType: Automation
      Content:
        description: SSM Automation for Back up all databases in SQL Server and install and restore to SQL Developer edition
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          InstanceId:
            type: String
            description: "(Required) The instance running Windows Server 2008 R2 or above,
              SQL Server 2008 or above, with the SSM agent installed."
          IamInstanceProfile:
            type: String
            description: "(Required) The IAM instance profile managed policy attached. Please
              refer to https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html
              for more information."
            default: !Ref SSMInstanceProfile
          SubnetId:
            type: String
            description: "(Required) Provide a subnet for the process. Verify that
              the subnet has outbound connectivity to AWS services, Amazon S3, and Microsoft
              (to download patches)."
            allowedPattern: "^subnet-[a-z0-9]{8,17}$"
          SecurityGroupId:
            type: String
            description: "(Required) Provide a security group for the process. Verify that
              the security group and the subnet within the same VPC ID."
            allowedPattern: "^sg-[a-z0-9]{8,17}$"
          MSsqlSecretKey:
            type: String
            description: "(Required) The name of an Secret Key that have access this permission to the SQL server."
            default: !Ref MSsqlSecretKey
          NoReboot:
            type: Boolean
            description: "(Optional) Do not reboot the instance before creating the image."
            default: false
          AutomationAssumeRole:
            type: String
            description: '(Required) The Amazon Resource Name (ARN) of the IAM role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to operate this runbook.'
            default: !GetAtt AWSSystemsManagerAutomationRole.Arn
        mainSteps:
        - name: assertSSMAgentOnline
          action: aws:assertAwsResourceProperty
          maxAttempts: 3
          timeoutSeconds: 300
          onFailure: Abort
          inputs:
            Service: ssm
            Api: DescribeInstanceInformation
            InstanceInformationFilterList:
            - key: InstanceIds
              valueSet:
              - "{{ InstanceId }}"
            PropertySelector: "$.InstanceInformationList[0].PingStatus"
            DesiredValues:
            - Online
          isCritical: 'true'
          nextStep: checkPrerequisite
        - name: checkPrerequisite
          action: aws:runCommand
          maxAttempts: 3
          onFailure: Abort
          timeoutSeconds: 300
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ InstanceId }}"
            Parameters:
              commands: |-
                  write-host "Check if there is a 10GB of a free space on boot volume drive"
          isCritical: 'true'
          nextStep: prepScript
        - name: prepScript
          action: aws:runCommand
          maxAttempts: 3
          onFailure: Abort
          timeoutSeconds: 300
          inputs:
            DocumentName: !Ref CommandDocumentSqlDevMigration
            InstanceIds:
              - "{{ InstanceId }}"
          isCritical: 'true'
          nextStep: sourceInstanceDetails
        - name: sourceInstanceDetails
          action: aws:executeAwsApi
          maxAttempts: 2
          onFailure: Abort
          timeoutSeconds: 300
          inputs:
            Service: ec2
            Api: DescribeInstances
            InstanceIds:
              - "{{ InstanceId }}"
          outputs:
          - Name: InstanceType
            Selector: "$.Reservations[0].Instances[0].InstanceType"
            Type: String
          - Name: KeyName
            Selector: "$.Reservations[0].Instances[0].KeyName"
            Type: String
          - Name: AvailabilityZone
            Selector: "$.Reservations[0].Instances[0].Placement.AvailabilityZone"
            Type: String
          - Name: RootDeviceName
            Selector: "$.Reservations[0].Instances[0].RootDeviceName"
            Type: String
          - Name: SubnetId
            Selector: "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId"
            Type: String
          - Name: Platform
            Selector: "$.Reservations[0].Instances[0].Platform"
            Type: String
          - Name: UsageOperation
            Selector: "$.Reservations[0].Instances[0].UsageOperation"
            Type: String
          - Name: SecurityGroupIds
            Selector: "$.Reservations[0].Instances[0].SecurityGroups..GroupId"
            Type: StringList
          isCritical: 'false'
          nextStep: assertRootVolumeIsEbs
        - name: assertRootVolumeIsEbs
          action: aws:assertAwsResourceProperty
          onFailure: Abort
          maxAttempts: 2
          timeoutSeconds: 300
          inputs:
            Service: ec2
            Api: DescribeInstances
            InstanceIds:
              - "{{ InstanceId }}"
            PropertySelector: "$.Reservations[0].Instances[0].RootDeviceType"
            DesiredValues:
            - ebs
          isCritical: 'true'
          nextStep: createAMI
        - name: createAMI
          action: aws:executeAwsApi
          maxAttempts: 2
          onFailure: step:deleteSourceInstanceAMI
          inputs:
            Service: ec2
            Api: CreateImage
            InstanceId: "{{ InstanceId }}"
            Name: SQL_Dev_Edition_{{ automation:EXECUTION_ID }}
            NoReboot: "{{ NoReboot }}"
          outputs:
          - Name: ImageId
            Selector: "$.ImageId"
            Type: String
          nextStep: tagSourceInstanceAMI
        - name: tagSourceInstanceAMI
          action: aws:createTags
          onFailure: step:deleteSourceInstanceAMI
          inputs:
            ResourceIds:
            - "{{ createAMI.ImageId }}"
            Tags:
            - Key: SQL_Dev_Edition_{{ automation:EXECUTION_ID }}
              Value: 'SourceInstanceId: {{ InstanceId }}'
            - Key: SystemsManagerAutomationExecutionId
              Value: '{{ automation:EXECUTION_ID }}'
            ResourceType: EC2
          isCritical: 'true'
          nextStep: waitForSourceInstanceAMItoReady
        - name: waitForSourceInstanceAMItoReady
          action: aws:waitForAwsResourceProperty
          onFailure: step:deleteSourceInstanceAMI
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeImages
            ImageIds:
            - "{{ createAMI.ImageId }}"
            PropertySelector: "$.Images[0].State"
            DesiredValues:
            - available
          nextStep: prepScriptCleanup
        - name: prepScriptCleanup
          action: aws:runCommand
          onFailure: Continue
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ InstanceId }}"
            Parameters:
              commands: |-
                  # The name of your scheduled task.
                  $taskName = "SQLDevAddRoutes"

                  # Unregister the scheduled task
                  Unregister-ScheduledTask -TaskName $taskName -Confirm:$false

                  write-host "Scheduled Task name SQLDevAddRoutes has been deleted"

                  #Delete the folder and the Script
                  Remove-Item -LiteralPath "C:\AWSsqlDeveloperEditionBlog\SQLDevAddRoutesScript" -Force -Recurse
                  write-host "Directory C:\AWSsqlDeveloperEditionBlog\SQLDevAddRoutesScript and it's content has been deleted"
          isCritical: 'true'
          nextStep: createTargetInstance
        - name: createTargetInstance
          action: aws:runInstances
          timeoutSeconds: 2700
          maxAttempts: 3
          onFailure: step:deleteSourceInstanceAMI
          inputs:
            ImageId: "{{ createAMI.ImageId }}"
            InstanceType: "{{ sourceInstanceDetails.InstanceType }}"
            MinInstanceCount: 1
            MaxInstanceCount: 1
            IamInstanceProfileName: "{{ IamInstanceProfile }}"
            BlockDeviceMappings:
              - DeviceName: '/dev/sda1'
                Ebs:
                  DeleteOnTermination: true
            NetworkInterfaces:
              - DeviceIndex: 0
                AssociatePublicIpAddress: true
                SubnetId: "{{ SubnetId }}"
                Groups:
                  - "{{ SecurityGroupId }}"
            TagSpecifications:
            - ResourceType: instance
              Tags:
              - Key: Name
                Value: SQL_Dev_Edition_{{ automation:EXECUTION_ID }}
              - Key: AMIid
                Value: '{{ createAMI.ImageId }}'
              - Key: SystemsManagerAutomationExecutionId
                Value: '{{ automation:EXECUTION_ID }}'
          isCritical: 'true'
          nextStep: getTargetInstance
        - name: getTargetInstance
          action: aws:executeAwsApi
          onFailure: step:stopTargetInstance
          inputs:
            Service: ec2
            Api: DescribeInstances
            Filters:
            - Name: tag:Name
              Values:
              - SQL_Dev_Edition_{{ automation:EXECUTION_ID }}
          outputs:
          - Name: InstanceId
            Selector: "$.Reservations[0].Instances[0].InstanceId"
            Type: String
          - Name: State
            Selector: "$.Reservations[0].Instances[0].State.Name"
          - Name: UsageOperation
            Selector: "$.Reservations[0].Instances[0].UsageOperation"
            Type: String
          isCritical: 'true'
          nextStep: waitForTargetInstanceToReady
        - name: waitForTargetInstanceToReady
          action: aws:waitForAwsResourceProperty
          onFailure: step:rebootTargetInstanceToBeReady
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstanceStatus
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            PropertySelector: "$.InstanceStatuses[0].InstanceStatus.Details[0].Status"
            DesiredValues:
            - passed
          isCritical: 'false'
          nextStep: waitForSSMAgentOnlineOnTargetInstance
        - name: rebootTargetInstanceToBeReady
          action: aws:executeAwsApi
          onFailure: step:waitForTargetInstanceToBeReadyAfterReboot
          inputs:
            Service: ec2
            Api: RebootInstances
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
          isCritical: 'false'
          nextStep: waitForTargetInstanceToBeReadyAfterReboot
        - name: waitForTargetInstanceToBeReadyAfterReboot
          action: aws:waitForAwsResourceProperty
          onFailure: step:stopTargetInstance
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstanceStatus
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            PropertySelector: "$.InstanceStatuses[0].InstanceStatus.Details[0].Status"
            DesiredValues:
            - passed
          isCritical: 'true'
          nextStep: waitForSSMAgentOnlineOnTargetInstance
        - name: waitForSSMAgentOnlineOnTargetInstance
          action: aws:waitForAwsResourceProperty
          timeoutSeconds: 600
          maxAttempts: 3
          onFailure: step:stopTargetInstance
          inputs:
            Service: ssm
            Api: DescribeInstanceInformation
            InstanceInformationFilterList:
            - key: InstanceIds
              valueSet:
              - "{{ getTargetInstance.InstanceId }}"
            PropertySelector: "$.InstanceInformationList[0].PingStatus"
            DesiredValues:
            - Online
          isCritical: 'true'
          nextStep: stopTargetInstancePreBackup
        - name: stopTargetInstancePreBackup
          action: aws:changeInstanceState
          onFailure: Continue
          inputs:
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            DesiredState: stopped
          nextStep: waitForTargetInstanceToBeStoppedPreBackup
        - name: waitForTargetInstanceToBeStoppedPreBackup
          action: aws:waitForAwsResourceProperty
          onFailure: step:forceStopTargetInstancePreBackup
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstanceStatus
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            IncludeAllInstances: true
            PropertySelector: "$.InstanceStatuses[0].InstanceState.Name"
            DesiredValues:
            - stopped
          nextStep: branchOnUsageOperation
        - name: forceStopTargetInstancePreBackup
          action: aws:changeInstanceState
          inputs:
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            CheckStateOnly: false
            DesiredState: stopped
            Force: true
        - name: branchOnUsageOperation
          action: aws:branch
          maxAttempts: 3
          inputs:
            Choices:
            - Or:
              - Variable: "{{ getTargetInstance.UsageOperation }}"
                StringEquals: "RunInstances:0102"
              - Variable: "{{ getTargetInstance.UsageOperation }}"
                StringEquals: "RunInstances:0006"
              NextStep: CreateLicenseConversionTaskForResource
            Default: deleteSourceInstanceAMI
          isCritical: 'true'
        - name: CreateLicenseConversionTaskForResource
          action: aws:executeAwsApi
          maxAttempts: 2
          inputs:
            Service: license-manager
            Api: CreateLicenseConversionTaskForResource
            ResourceArn: "arn:{{ global:AWS_PARTITION }}:ec2:{{ global:REGION }}:{{ global:ACCOUNT_ID }}:instance/{{ getTargetInstance.InstanceId }}"
            SourceLicenseContext:
              UsageOperation:
                "{{ getTargetInstance.UsageOperation }}"
            DestinationLicenseContext:
              UsageOperation:
                RunInstances:0002
        - name: waitForTargetInstanceLicenseConversion
          action: aws:waitForAwsResourceProperty
          onFailure: step:deleteSourceInstanceAMI
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstances
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            PropertySelector: "$.Reservations[0].Instances[0].UsageOperation"
            DesiredValues:
            - RunInstances:0002
        - name: StartTargetInstancePostConversion
          action: aws:changeInstanceState
          onFailure: Continue
          inputs:
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            DesiredState: running
          nextStep: waitForTargetInstanceToBeStartPostConversion
        - name: waitForTargetInstanceToBeStartPostConversion
          action: aws:waitForAwsResourceProperty
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstanceStatus
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            IncludeAllInstances: true
            PropertySelector: "$.InstanceStatuses[0].InstanceState.Name"
            DesiredValues:
            - running
          nextStep: assertSSMAgentOnlinePostConversion
        - name: assertSSMAgentOnlinePostConversion
          action: aws:assertAwsResourceProperty
          maxAttempts: 3
          timeoutSeconds: 300
          onFailure: Abort
          inputs:
            Service: ssm
            Api: DescribeInstanceInformation
            InstanceInformationFilterList:
            - key: InstanceIds
              valueSet:
              - "{{ getTargetInstance.InstanceId }}"
            PropertySelector: "$.InstanceInformationList[0].PingStatus"
            DesiredValues:
            - Online
          isCritical: 'true'
        - name: runScriptCreateDbsBackup
          action: aws:runCommand
          maxAttempts: 3
          onFailure: step:stopTargetInstance
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            Parameters:
              commands: |-
                #$Backup and Uninstall SQL Ent
                # Save databases' metadata
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Install-PackageProvider -Name "Nuget" -RequiredVersion "2.8.5.201" -Force
                Import-PackageProvider -Name "Nuget" -RequiredVersion "2.8.5.201" -Force
                Install-Module SQLServer -Force -AllowClobber
                Import-Module SQLServer -Force
                #Variable to Change
                $SQLCredentialSecretValue = (Get-SSMParameterValue -Name /aws/reference/secretsmanager/{{ MSsqlSecretKey }} -WithDecryption $True).Parameters[0].Value | ConvertFrom-Json
                $username = $SQLCredentialSecretValue.Username
                $password = $SQLCredentialSecretValue.Password
                $CopySystemFileLocation= "C:\Windows\Temp"
                    #Find No.of SQL Instances Installed
                    $TotalInstances = Get-Service | Where-Object { $_.DisplayName -like "SQL Server (*" } | Measure-Object
                    If ($TotalInstances.Count -gt 1) {
                        Write-Host "Multiple SQL Instances are Installed on this Server.Not supported at this time" -Color Red
                        Throw
                    }
                    elseif ($TotalInstances.Count -eq 0) {
                        Write-Host "SQL is not installed on this machine" -Color Red
                        Throw
                    }
                            #Check Whether Enterprise Edition is installed or not
                            $InstanceName= (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server').InstalledInstances
                            $InstanceID=Get-ItemPropertyValue -Path 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL' -Name $InstanceName
                            $Edition = Get-ItemPropertyValue -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\${InstanceID}\Setup" -Name 'Edition'
                            $Port=Get-ItemPropertyValue -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\${InstanceID}\MSSQLServer\SuperSocketNetLib\Tcp\IPAll" -Name "TcpPort"
                            $InstanceName |Out-File -FilePath C:\Windows\temp\InstanceName.txt
                            (get-itemproperty -Path ("HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL")).MSSQLSERVER | Out-File -FilePath C:\Windows\temp\InstanceYear.txt
                            If ($InstanceName -eq 'MSSQLSERVER')
                            {
                            $SQLInstanceName ="localhost"
                            Write-Host $SQLInstanceName
                            }
                            else
                            {
                            $SQLInstanceName="localhost\"+$InstanceName #+','+ $Port
                            Write-Host $SQLInstanceName
                            }
                    if ($Edition -match "Enterprise Edition" -or $Edition -match "Standard Edition") {
                            Write-Host "Checking whether sql is running or not"
                    }
                else {
                        Write-Host "Detected version is $SQLSourceEdition. You must have Enterprise or Standard edition to proceed. Exiting..."
                        # $ErrorActionPreference = "Stop"
                        Throw
                    }
                #ConnectionString
                $ConnectionString = "Server= $SQLInstanceName;Database=Master;User Id = $username;Password = $password;TrustServerCertificate=True"
                    #Get Current Time Stamp
                    $timeStamp = Get-Date -format yyyy_MM_dd_HHmmss
                    #Check If SQL Server is Running or not
                    $InstanceService=Get-Service | Where-Object {$_.DisplayName -like "SQL Server (*"}
                    $status =get-service $InstanceService.Name | select Status
                    If ($status.Status -eq "Running") {
                        Write-Host "SQLServer is Running"
                    }
                    Else {
                        Write-Host "SQL Server is not running"
                        Throw
                    }
                    Try {
                        #Check If SQL Server is Clustered or not
                        [array]$Clustered = Invoke-Sqlcmd -ConnectionString $ConnectionString -Query "select  SERVERPROPERTY('IsClustered') as IsClustered,SERVERPROPERTY('IsHadrEnabled') as IsHadrEnabled" -ErrorAction stop
                    }
                    Catch {
                        Write-Host ($Error[0].Exception)
                        Throw
                    }
                    if ($Clustered.isClustered -eq 1 -or $Clustered.IsHadrEnabled -eq 1) {
                        Write-Host "SQL is clustered or Part of Always on Availability Groups. Not supported at this time" -Color Red
                        Throw
                    }
                    #GET DB File Location (we are getting this info ,Uninstalling SQL will not remove tempdb files if they are in custom location)
                    [array]$TempDBFileLocation = Invoke-Sqlcmd -ConnectionString $ConnectionString  -Query "USE tempdb;
                                                                    SELECT
                                                                      physical_name
                                                                    FROM sys.database_files;"
                    $TempDBFileLocation.physical_name
                    $userdbfilepath="C:\windows\temp"+'\userdatabase_path.csv'
                            $SQLPathCOMMAND="SET NOCOUNT ON
                            DECLARE    @cmd        VARCHAR(MAX),
                                        @dbname     VARCHAR(200),
                                        @prevdbname VARCHAR(200)
                            SELECT @cmd = '', @dbname = ';', @prevdbname = ''
                            CREATE TABLE #Attach (Seq INT IDENTITY(1,1) PRIMARY KEY,
                                                    dbname     SYSNAME NULL,
                                                    fileid     INT NULL,
                                                    filename   VARCHAR(1000) NULL,
                                                    TxtAttach  VARCHAR(MAX) NULL
                                                    )
                            INSERT INTO #Attach
                            SELECT
                                DISTINCT DB_NAME(dbid) AS dbname, fileid, filename, CONVERT(VARCHAR(MAX),'') AS TxtAttach
                            FROM master.dbo.sysaltfiles
                            WHERE dbid IN (SELECT dbid FROM master.dbo.sysaltfiles )
                            AND DATABASEPROPERTYEX( DB_NAME(dbid) , 'Status' ) = 'ONLINE'
                            AND DB_NAME(dbid) NOT IN ('master','tempdb','msdb','model')
                            ORDER BY dbname, fileid, filename
                            UPDATE #Attach
                            SET @cmd = TxtAttach =
                            CASE WHEN dbname <> @prevdbname
                            THEN CONVERT(VARCHAR(200),'exec sp_attach_db @dbname = N''' + dbname + '''')
                            ELSE @cmd
                            END +',@filename' + CONVERT(VARCHAR(10),fileid) + '=N''' + filename +'''',
                            @prevdbname = CASE WHEN dbname <> @prevdbname THEN dbname ELSE @prevdbname END,
                            @dbname = dbname
                            FROM #Attach  WITH (INDEX(0),TABLOCKX)
                            OPTION (MAXDOP 1)
                            SELECT dbname,TxtAttach
                            from
                            (SELECT dbname, MAX(TxtAttach) AS TxtAttach FROM #Attach
                            GROUP BY dbname) AS x
                            DROP TABLE #Attach
                            GO"
                            $userdbpathoutput=invoke-sqlcmd -ConnectionString $ConnectionString   -query $SQLPathCOMMAND | Export-Csv -Path $userdbfilepath -NoTypeInformation
                            $systemfiles=Invoke-sqlcmd -ConnectionString $ConnectionString  -Query "select filename from sysaltfiles where dbid in (1,3,4)"
                            $InstanceService=(Get-Service | Where-Object {$_.DisplayName -like "SQL Server (*"})
                            # First stop dependencies.
                            Get-Service -Name $InstanceService.Name -DependentServices | Stop-Service
                            # stop SQL
                            Get-Service -Name $InstanceService.Name | Stop-Service
                            Write-Host "SQL Service has been stopped"
                            $files=$systemfiles.filename
                            foreach ($file in $files)
                            {
                                Copy-Item -Path $file -Destination $CopySystemFileLocation -Force
                            }
                ##Start uninstallation process##
                #Setup File Location
                $setupfileLocation = Get-ChildItem -Recurse -Include setup.exe -Path "$env:ProgramFiles\Microsoft SQL Server" -ErrorAction SilentlyContinue |
                Where-Object { $_.FullName -match 'Setup Bootstrap\\SQL' -or $_.FullName -match 'Bootstrap\\Release\\Setup.exe' -or $_.FullName -match 'Bootstrap\\Setup.exe' } |
                Sort-Object FullName -Descending | Select-Object -First 1

                $DirectoryName=$setupfileLocation.DirectoryName
                Write-Output "SQL Uninstallation Started"
                $Path=$DirectoryName
                $InstanceName = $InstanceService.Name
                $uninstallaction="/ACTION=""unInstall"" /Q /FEATURES=SQL,AS,RS,IS,Tools /InstanceName=$InstanceName"
                Start-Process -WorkingDirectory $Path setup.exe $uninstallaction -Verb runAs -Wait
                if (!(Get-Service mssqlserver)){
                    Write-Output "SQL Uninstallation Completed"
                    }
                else {
                    Write-Output "SQL Uninstallation failed"
                    Throw
                    }
          isCritical: 'true'
          nextStep: runScriptPostBackup
        - name: runScriptPostBackup
          action: aws:runCommand
          maxAttempts: 3
          onFailure: step:stopTargetInstance
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            Parameters:
              commands: !Sub
                - |
                  #Enable AutoLogon
                  $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
                  $property = (Get-ItemProperty -Path $RegPath).AutoAdminLogon

                  if ($property -ne 1) {
                    $ServerName = $env:COMPUTERNAME
                    $AdminSecretValue = (Get-SSMParameterValue -Name /aws/reference/secretsmanager/${ LocalAdministratorCredential } -WithDecryption $True).Parameters[0].Value | ConvertFrom-Json
                    $Username = $AdminSecretValue.Username
                    $Password = $AdminSecretValue.Password
                    $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
                    $LocalAdministrator = $ServerName + '\' + $Username
                    Set-LocalUser -Name $Username -Password $SecurePassword

                    Set-ItemProperty -Path $RegPath -Name "AutoAdminLogon" -Value "1" -type String
                    Set-ItemProperty -Path $RegPath -Name "DefaultUsername" -Value "$LocalAdministrator" -type String
                    Set-ItemProperty -Path $RegPath -Name "DefaultPassword" -Value "$Password" -type String
                    exit 3010
                  }
                - LocalAdministratorCredential:
                    !Sub
                      - 'LocalAdministratorSecret-${RandomGUID}'
                      - { RandomGUID: !Select [0, !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId ]]]] }
          isCritical: 'true'
          nextStep: runScriptInstallSqlDev
        - name: runScriptInstallSqlDev
          action: aws:runCommand
          maxAttempts: 3
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            Parameters:
              commands: !Sub
                - |
                  $ServerName = $env:COMPUTERNAME
                  $AdminSecretValue = (Get-SSMParameterValue -Name /aws/reference/secretsmanager/${ LocalAdministratorCredential } -WithDecryption $True).Parameters[0].Value | ConvertFrom-Json
                  $Username = $AdminSecretValue.Username
                  $Password = $AdminSecretValue.Password
                  $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
                  $LocalAdministrator = $ServerName + '\' + $Username
                  # Set-LocalUser -Name $Username -Password $SecurePassword

                  $Credential = New-Object System.Management.Automation.PsCredential($LocalAdministrator,$SecurePassword)
                  $InstanceYear = Get-Content C:\Windows\temp\InstanceYear.txt

                  if ($InstanceYear -match 14){
                    $SourceVersionYear = "2017"
                    Write-Output "Installing SQL Server 2017 Developer Edition"
                    Invoke-Command -ComputerName $ServerName -Credential $Credential -ScriptBlock {
                      [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072;
                      $path = New-Item -Path 'c:\devsqlinstall' -ItemType Directory -Force; CD $path
                      $Uninstall = Invoke-CimMethod -Query "SELECT * FROM Win32_Product WHERE Name = 'Microsoft SQL Server 2012 Native Client '" -MethodName Uninstall -Confirm:$false
                      $result = $Uninstall.ReturnValue
                      Write-Output "Uninstallation of Microsoft SQL Server 2012 Native Client completed with exit code $result"
                      Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/p/?linkid=853016" -OutFile ".\SQLServer2017-SSEI-Dev.exe"
                      Start-Process .\SQLServer2017-SSEI-Dev.exe -ArgumentList @("/Q", "/IACCEPTSQLSERVERLICENSETERMS", "/ACTION=install") -Wait -NoNewWindow -Verbose
                      }
                  }
                  elseif ($InstanceYear -match 15){
                    $SourceVersionYear = "2019"
                    Write-Output "Installing SQL Server 2019 Developer Edition"
                    Invoke-Command -ComputerName $ServerName -Credential $Credential -ScriptBlock {
                      [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072;
                      $path = New-Item -Path 'c:\devsqlinstall' -ItemType Directory -Force; CD $path
                      $Uninstall = Invoke-CimMethod -Query "SELECT * FROM Win32_Product WHERE Name = 'Microsoft SQL Server 2012 Native Client '" -MethodName Uninstall -Confirm:$false
                      $result = $Uninstall.ReturnValue
                      Write-Output "Uninstallation of Microsoft SQL Server 2012 Native Client completed with exit code $result"
                      Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=866662" -OutFile ".\SQL2019-SSEI-Dev.exe"
                      Start-Process .\SQL2019-SSEI-Dev.exe -ArgumentList @("/Q", "/IACCEPTSQLSERVERLICENSETERMS", "/ACTION=install") -Wait -NoNewWindow -Verbose
                        }
                  }
                  elseif ($InstanceYear -match 16){
                    $SourceVersionYear = "2022"
                    Write-Output "Installing SQL Server 2022 Developer Edition"
                    Invoke-Command -ComputerName $ServerName -Credential $Credential -ScriptBlock {
                      [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072;
                      $path = New-Item -Path 'c:\devsqlinstall' -ItemType Directory -Force; CD $path
                      $Uninstall = Invoke-CimMethod -Query "SELECT * FROM Win32_Product WHERE Name = 'Microsoft SQL Server 2012 Native Client '" -MethodName Uninstall -Confirm:$false
                      $result = $Uninstall.ReturnValue
                      Write-Output "Uninstallation of Microsoft SQL Server 2012 Native Client completed with exit code $result"
                      Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/p/?linkid=2215158&clcid=0x409&culture=en-us&country=us" -OutFile ".\SQL2022-SSEI-Dev.exe"
                      Start-Process .\SQL2022-SSEI-Dev.exe -ArgumentList @("/Q", "/IACCEPTSQLSERVERLICENSETERMS", "/ACTION=install") -Wait -NoNewWindow -Verbose
                        }
                  }

                  else {
                    Write-Output "Unsupported Source SQL version. This automation only supports SQL Server 2017, 2019 and 2022"
                    Throw
                  }

                  #After Installing SQL, disable auto-logon
                  $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
                  $property = (Get-ItemProperty -Path $RegPath).AutoAdminLogon
                  Set-ItemProperty -Path $RegPath -Name "AutoAdminLogon" -Value "1" -type String
                  Set-ItemProperty -Path $RegPath -Name "DefaultUsername" -Value "$LocalAdministrator" -type String
                  Set-ItemProperty -Path $RegPath -Name "DefaultPassword" -Value "$Password" -type String

                  If (get-service mssqlserver){
                      Write-Output "SQL installed successfully"
                      }
                  else {
                      Write-Output "SQL installation failed"
                      Throw
                  }
                - LocalAdministratorCredential:
                    !Sub
                      - 'LocalAdministratorSecret-${RandomGUID}'
                      - { RandomGUID: !Select [0, !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId ]]]] }
          onFailure: step:stopTargetInstance
          isCritical: 'true'
          nextStep: SQLRestore
        - name: SQLRestore
          action: aws:runCommand
          maxAttempts: 3
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            Parameters:
              commands: !Sub
                - |
                  $ServerName = $env:COMPUTERNAME
                  $AdminSecretValue = (Get-SSMParameterValue -Name /aws/reference/secretsmanager/${ LocalAdministratorCredential } -WithDecryption $True).Parameters[0].Value | ConvertFrom-Json
                  $Username = $AdminSecretValue.Username
                  $Password = $AdminSecretValue.Password
                  $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
                  $LocalAdministrator = $ServerName + '\' + $Username
                  # Set-LocalUser -Name $Username -Password $SecurePassword

                  $Credential = New-Object System.Management.Automation.PsCredential($LocalAdministrator,$SecurePassword)
                  Invoke-Command -ComputerName $ServerName -Credential $Credential -ScriptBlock {
                      $backupfolder = "C:\Windows\Temp"
                      #$backupfolder = $using:backuplocation + "\" + $using:timeStamp
                      $userdbfilepath = $backupfolder + '\userdatabase_path.csv'
                      $InstanceName = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server').InstalledInstances
                      $InstanceID = Get-ItemPropertyValue -Path 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL' -Name $InstanceName
                      $SQLInstanceName = $InstanceName
                      $Edition = Get-ItemPropertyValue -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\`$`{InstanceID`}\Setup" -Name 'Edition'

                      #Write-Log "Starting User DB Attachment"
                      Import-CSV $userdbfilepath | ForEach-Object {
                          #Current row object
                          $CSVRecord = $_
                          $attachcmd2 = $CSVRecord.'TxtAttach'
                          $dbname = $CSVRecord.'dbname'
                          Write-Host $attachcmd2
                          try {

                              Invoke-sqlcmd -ServerInstance localhost -Query $attachcmd2 -QueryTimeout 3600 -TrustServerCertificate

                          }
                          Catch {

                              write-Host ($Error[0].Exception)
                              Throw
                          }
                      }
                      ###WORKS UP TO THIS POINT. NEED TO STOP/START SQL TO CONFIRM IT DOES NOT BREAK AT THIS POINT###

                      #Write-Log "Starting System Databases recovery" -Color Green
                      $newsystemfiles = (Invoke-sqlcmd -ServerInstance localhost -TrustServerCertificate -Query "select filename from sysaltfiles where dbid in (1,3,4)").filename
                      #Write-Log "Stopping SQL instance"
                      Stop-Service  MSSQLSERVER
                      foreach ($newsystemfile in $newsystemfiles) {
                          $newfilename = $newsystemfile + '_old'
                          Rename-Item -Path $newsystemfile -NewName $newfilename
                          $pathpos = $newsystemfile.LastIndexOf("\")
                          $dbfilepos = ($newsystemfile.length - $pathpos - 1)
                          $systempath = $newsystemfile.Substring(0, $pathpos + 1)
                          $dbfilename = $newsystemfile.SubString($newsystemfile.length - $dbfilepos)
                          $oldfile = (Get-ChildItem $backupfolder\ -Recurse -Include $dbfilename).name
                          Copy-Item -Path $backupfolder\$oldfile -Destination $systempath\
                      }
                      Write-Output "System database files copied"
                      Write-Output "Starting SQL Service"
                      Start-Service  MSSQLSERVER
                  }
                - LocalAdministratorCredential:
                    !Sub
                      - 'LocalAdministratorSecret-${RandomGUID}'
                      - { RandomGUID: !Select [0, !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId ]]]] }
          onFailure: step:stopTargetInstance
          isCritical: 'true'
          nextStep: checkAfterSQLRestore
        - name: checkAfterSQLRestore
          action: aws:runCommand
          maxAttempts: 3
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            Parameters:
              commands: |-
                  $UserDBs = invoke-Sqlcmd -ServerInstance localhost -Query "select name from sys.databases where database_id > 4" -TrustServerCertificate
                  if (!$UserDBs){
                      Write-Output "Restore of SQL databses failed"
                      Throw
                      }
                  else {
                      Write-Output "Restore of SQL databses SUCCEEDED"
                      }
          onFailure: step:stopTargetInstance
          isCritical: 'true'
          nextStep: stopTargetInstance
        - name: stopTargetInstance
          action: aws:changeInstanceState
          onFailure: Continue
          inputs:
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            DesiredState: stopped
          nextStep: waitForTargetInstanceToBeStopped
        - name: waitForTargetInstanceToBeStopped
          action: aws:waitForAwsResourceProperty
          onFailure: step:forceStopTargetInstance
          timeoutSeconds: 600
          maxAttempts: 2
          inputs:
            Service: ec2
            Api: DescribeInstanceStatus
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            IncludeAllInstances: true
            PropertySelector: "$.InstanceStatuses[0].InstanceState.Name"
            DesiredValues:
            - stopped
          nextStep: branchOnSQLRestoreSuccess
        - name: forceStopTargetInstance
          action: aws:changeInstanceState
          inputs:
            InstanceIds:
              - "{{ getTargetInstance.InstanceId }}"
            CheckStateOnly: false
            DesiredState: stopped
            Force: true
        - name: branchOnSQLRestoreSuccess
          action: aws:branch
          maxAttempts: 3
          inputs:
            Choices:
            - Variable: "{{ checkAfterSQLRestore.Output }}"
              Contains: Restore of SQL databses SUCCEEDED
              NextStep: deleteSourceInstanceAMI
            Default: deleteSourceInstanceAMI
          isCritical: 'true'
        - name: deleteSourceInstanceAMI
          action: aws:deleteImage
          inputs:
            ImageId: "{{ createAMI.ImageId }}"
          maxAttempts: 3
          isCritical: 'true'
          onFailure: Continue
        outputs:
            - getTargetInstance.InstanceId
            - getTargetInstance.State
Outputs:
  AWSSystemsManagerAutomationRole:
    Description: AWS Systems Manager Automation Execution Role
    Value: !Ref AWSSystemsManagerAutomationRole
  SystemsManagerAutomationDocumentforSqlDev:
    Description: Systems Manager Automation Document to automate the installation and inplace migration of the databases to Microsoft SQL developer edition.
    Value: !Ref AutomationDocumentSqlDevMigration
